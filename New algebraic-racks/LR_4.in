% Saved by Prover9-Mace4 Version 0.5, December 2007.

set(ignore_option_dependencies). % GUI handles dependencies

if(Prover9). % Options for Prover9
  assign(max_weight, 25).
  set(restrict_denials).
  assign(new_constants, 1).
  assign(max_seconds, 60).
end_if.

if(Mace4).   % Options for Mace4
  assign(max_seconds, 60).
end_if.

formulas(assumptions).

% Distributivity from a nonstandard Boolean algebra (BA) basis.

% Prover9 should produce a proof in a few seconds.

% Nonstandard Boolean algebra basis.
% Rack Axioms

%all x (pow8 (x) = (((((((x * x) * x) * x) * x) * x) * x) * x)).
all x (pow10 (x) = ((((((((x * x) * x) * x) * x) * x) * x) * x) *x) *x).

all x all y all z ((x*y)*z = (x*z)*(y*z)).
all x all y ((x@y) * y = x).
all x all y ((x*y)@y = x).

all x (x = pow10 (x)).

all x all y (U(x, y)<-> (y = (((x*x)*x)*x)*x)).
all x all y (D(x, y)<-> (y = (((x*x)*x)*x)*x)).

all x (pow (x) = ((((x*x)*x)*x)*x)*x).
all x (neg_pow (x) = ((((x@x)@x)@x)@x)@x).

%U(a, b).
%U(b, a).

end_of_list.

formulas(goals).

%a = b.
%a*a = a.
%Predicate Axioms

%all x (U(x*x,pow (x))). 
%all x (D(pow (x), x)).
%B

%all x (U(x,neg_pow (x))). 
%all x (D(neg_pow (x), x@x)).

%C
%all x (D(x,neg_pow (x))). 
%all x (U(neg_pow (x), x@x)).

%D
%all x (D(x*x,pow (x))). 
%all x (U(pow (x), x)).
%Reidemeister Axioms
%Move 1
%A
all x all y all z ((U(x*z, y) & D(y, z))  -> (x = z)).
%all x all y all z ((U(x*z, y) & D(y, z))  -> (y =pow (x))).

%B
%all x all y all z ((D(y, z@x) & U(x, y))  -> (x = z)).
%all x all y all z ((D(y, z@x) & U(x, y))  -> (y = neg_pow (x))).

%C

%all x all y all z ((D(x, y) & U(y, z@x))  -> (x = z)).
%all x all y all z ((D(x, y) & U(y, z@x))  -> (y = neg_pow (x))).

%D

%all x all y all z ((D(x*z, y) & U(y, z))  -> (x = z)).
%all x all y all z ((D(x*z, y) & U(y, z))  -> (y = pow (x))).

%Move 2
%A
%all x all y all z (U(x,y) -> U(x*z, y*z)).
%A-Inverse
%all x all y all z (U(x,y) -> U(x@z, y@z)).

%B
%all x all y all z (D(x,y) -> D(x*z, y*z)).
%B-Inverse
%all x all y all z (D(x,y) -> D(x@z, y@z)).

%C
%all x all y all z (U(x, y) -> (z@x)*y = z).

%C-Inverse
%all x all y all z (U(x, y) -> (z@y)*x = z).

%D
%all x all y all z (D(x,y) -> (z*y)@x = z). 

%D-Inverse
%all x all y all z (D(x, y) -> (z*x)@y = z).

end_of_list.

